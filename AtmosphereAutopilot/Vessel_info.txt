//Useful info about Vessel class.

public static float loadDistance = 2500f;
public static float unloadDistance = 2250f;

public Transform ReferenceTransform returns Vessel.vesselTransform or some part.GetReferenceTransform()

private bool SI_DLE is responsible for vessel persistence and can be set by vessel.IsPersistent. 
vessel.IsPersistent returns true if SI_DLE is true or one of it's parts is persistent.

public Vector3 CurrentCoM 
if vessel is packed (<300m) it yields
    arg_67_0 = this.CoM - this.obt_velocity * (double)TimeWarp.fixedDeltaTime;
else
    arg_67_0 = this.CoM + this.rb_velocity * Time.fixedDeltaTime;
    
this.obt_velocity is in global inertial plane

this.distancePackThreshold = 5000f;
this.distanceUnpackThreshold = 200f;
this.distanceLandedPackThreshold = 350f;
this.distanceLandedUnpackThreshold = 200f;

this.SetReferenceTransform(ShipConstruction.findFirstCrewablePart(this.rootPart));


public Vector3d GetWorldPos3D()
    if LandedOrSplashed
        returns arg_74_0 = this.orbit.referenceBody.GetWorldSurfacePosition(this.latitude, 
            this.longitude, this.altitude);
    else
        returns arg_74_0 = this.orbit.referenceBody.position + this.orbit.pos.xzy;
        
Part has GroundContact and WaterContact properties.

part.isControlSurface

// Initialization syntax
this.latitude = this.mainBody.GetLatitude(this.vesselTransform.position);
this.longitude = this.mainBody.GetLongitude(this.vesselTransform.position);
this.altitude = this.mainBody.GetAltitude(this.vesselTransform.position);
this.srfRelRotation = Quaternion.Inverse(this.mainBody.bodyTransform.rotation) * this.vesselTransform.rotation;
this.upAxis = FlightGlobals.getUpAxis(this.vesselTransform.position);
this.heightFromTerrain = Vector3.Dot(this.vesselTransform.position, this.upAxis);
this.terrainNormal = this.vesselTransform.InverseTransformDirection(this.upAxis);

// Order of callbacks
this.OnPreAutopilotUpdate(this.ctrlState);
this.OnAutopilotUpdate(this.ctrlState);
this.OnPostAutopilotUpdate(this.ctrlState);
this.OnFlyByWire(this.ctrlState);
this.rootPart.propagateControlUpdate(this.ctrlState);

public void MakeActive() 
    loads, then awakes modules/parts/crew etc.

public void GoOnRails()
    //fails if packed. If not packed, then:
    GameEvents.onVesselGoOnRails.Fire(this);
    this.ctrlState.Neutralize();
    

private bool CheckGroundCollision()
{
    ...
		Vector3 vector = this.vesselTransform.position;
		Vector3d a = FlightGlobals.getUpAxis(this.vesselTransform.position);
		Vector3d relSurfaceNVector = this.mainBody.GetRelSurfaceNVector(this.latitude, this.longitude);
		double num = this.mainBody.pqsController.GetSurfaceHeight(relSurfaceNVector) - 
            this.mainBody.Radius - this.mainBody.GetAltitude(this.vesselTransform.position);
		float num2 = Mathf.Max(15f, (float)num + 15f);
		vector += a * (double)num2;
		float distance = (float)(vector - this.mainBody.position).magnitude;
		if (Physics.Raycast(vector, -a, out this., distance, 32768))
		{
			float num3 = this.heightFromTerrain - (this..distance - num2);
			this.SetRotation(this.vesselTransform.rotation * Quaternion.FromToRotation(this.terrainNormal, 
                this.vesselTransform.InverseTransformDirection(this..normal)));
			this.Translate(a * (double)num3);
			return true;
		}
		return false;
}

public static Vector3d FlightGlobals.getUpAxis(Vector3d position)
{
	return (position - FlightGlobals.getMainBody(position).position).normalized;
}


public Vector3d CelestialBody.GetRelSurfaceNVector(double lat, double lon)
{
	return QuaternionD.AngleAxis(lon, Vector3d.down) * QuaternionD.AngleAxis(lat, Vector3d.forward) * Vector3d.right;
}

// FixedUpdate
this.CoM = this.findWorldCenterOfMass();
this.obt_velocity = this.orbit.GetRelativeVel();
this.obt_speed = this.obt_velocity.magnitude;
this.srf_velocity = this.orbit.GetVel() - this.mainBody.getRFrmVel(this.vesselTransform.position);
// rb - rigid_body
this.rb_velocity = this.rootPart.rb.GetPointVelocity(this.CoM);
this.angularVelocity = Quaternion.Inverse(this.ReferenceTransform.rotation) * this.rootPart.rb.angularVelocity;
// That's where we get that noisy angular velocity! It's taken from a rigidbody of a root part
this.MOI = this.findLocalMOI(this.CoM);
this.angularMomentum.x = this.MOI.x * this.angularVelocity.x;
this.angularMomentum.y = this.MOI.y * this.angularVelocity.y;
this.angularMomentum.z = this.MOI.z * this.angularVelocity.z;
this.upAxis = FlightGlobals.getUpAxis(this.mainBody, this.vesselTransform.position);
this.verticalSpeed = Vector3d.Dot(this.obt_velocity, this.upAxis);
this.srfSpeed = this.srf_velocity.magnitude;
this.horizontalSrfSpeed = this.srfSpeed - Math.Abs(this.verticalSpeed);


this.perturbation = this.acceleration - this.flightIntegrator.gForce - this.flightIntegrator.CentrifugalAcc -
    this.flightIntegrator.CoriolisAcc * 0.5f;
this.geeForce = this.perturbation.magnitude / 9.81;
this.geeForce_immediate = ((this.obt_velocity - this.) /
    (double)TimeWarp.fixedDeltaTime - this.flightIntegrator.gForce - this.flightIntegrator.CentrifugalAcc -
    this.flightIntegrator.CoriolisAcc * 0.5f).magnitude / 9.81;
this.staticPressure = FlightGlobals.getStaticPressure(this.vesselTransform.position, this.mainBody);
this.atmDensity = FlightGlobals.getAtmDensity(this.staticPressure);

// Properties
public Transform GetTransform()
{
	return this.ReferenceTransform;
}
public Vector3 GetObtVelocity()
{
    return this.obt_velocity;
}
public Vector3 GetSrfVelocity()
{
    return this.srf_velocity;
}
public Vector3 GetFwdVector()
{
    return this.ReferenceTransform.forward;
}
...
public Transform ReferenceTransform
{
    get
    {
        Transform arg_38_0;
        if (this. != null)
            arg_38_0 = this..GetReferenceTransform();
        }
        else
        {
            arg_38_0 = this.vesselTransform;
        }
        return arg_38_0;
    }
}
private void setReferenceTransform(Part p)
{
    this. = p;
}
// That thing is part, and in part we have
public Transform GetReferenceTransform()
{
	return this.;
}
//... and still in part
this. = base.transform;
this.partTransform = base.transform;

public void SetReferenceTransform(Part p)
{
	if (p != null)
	{
		this.referenceTransformId = p.flightID;
		this.setReferenceTransform(p);
	}
	else
	{
		this.referenceTransformId = 0u;
		this.setReferenceTransform(null);
	}
}
this.SetReferenceTransform(ShipConstruction.findFirstCrewablePart(this.rootPart));


private void Awake()
{
    this.vesselTransform = base.transform;
    ...
}